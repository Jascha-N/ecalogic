
function pow(X,Y)
  Z := 1;
  while Y > 0 upto Y do
    Z := Z * X;
    Y := Y-1
  end while;
  return Z
end function

function log(G,X)
  A := 1;
  N := 0;
  while A < X upto X do
    A := A*G;
    N := N+1
  end while;
  N := N-1;
  return N
end function

function sqrt(X)
  A := 1;
  while A*A < X upto X do
    A := A+1
  end while;
  A := A-1;
  return A
end function

function div(X,Y)
  N := 0;
  while X >= Y upto X do
    X := X-Y;
    N := N+1
  end while;
  return N
end function

function mod(X,Y)
  N := X-Y*div(X,Y);
  return N
end function

function horror(X,P)
  Y := 1;
  (* find the inverse of X mod P, if it exists at all *)
  while Y <= P upto P do
    if mod(Y*X, 1709) = 1 then
      Xinv := Y
    else
      skip
    end if;
    Y := Y + 1
  end while;

  (* >:) *)
  Y := 1;
  while Y <= Xinv upto Xinv do
    Y := Y+1
  end while;

  (* >:) *)
  Y := 1;
  if mod(Xinv,2) = 0 then
    A := X
  else
    A := P
  end if;

  while Y <= A upto A do 
    component::do()
  end while

  return X
end fuction

